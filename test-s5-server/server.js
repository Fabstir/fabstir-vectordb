/**
 * Local Enhanced S5.js HTTP Server for Integration Testing
 *
 * This server provides S5 storage functionality on port 5522 for testing
 * the vector database's real S5 persistence operations.
 *
 * REST API:
 * - PUT /s5/fs/{path} - Store data (binary body)
 * - GET /s5/fs/{path} - Retrieve data (binary response)
 * - DELETE /s5/fs/{path} - Delete data
 * - GET /health - Health check
 *
 * Based on @julesl23/s5js@0.9.0-beta
 */

// Polyfill IndexedDB and WebSocket for Node.js environment
import 'fake-indexeddb/auto';
import WebSocket from 'ws';
global.WebSocket = WebSocket;

import { S5 } from '@julesl23/s5js';
import http from 'http';

const PORT = process.env.PORT || 5522;
const HOST = process.env.HOST || '0.0.0.0';

// Single S5 instance (uses generated seed phrase for testing)
// In real usage, seed phrase comes from VectorDbConfig
let s5Instance = null;
// Use a valid BIP39 seed phrase generated by S5.js
const DEFAULT_SEED = 'fault twenty against sodium wear outside tuck lecture report style nothing toward appear also love';

/**
 * Initialize S5 instance
 */
async function initializeS5() {
  if (!s5Instance) {
    console.log('Initializing S5 instance...');

    const s5 = await S5.create({
      initialPeers: [
        "wss://z2DWuPbL5pweybXnEB618pMnV58ECj2VPDNfVGm3tFqBvjF@s5.ninja/s5/p2p"
      ]
    });

    // Recover identity from default seed phrase
    await s5.recoverIdentityFromSeedPhrase(DEFAULT_SEED);

    // Register on S5 portal (required for uploads)
    // Skip if already registered (handles server restarts)
    try {
      console.log('Registering on S5 portal...');
      await s5.registerOnNewPortal("https://s5.vup.cx");
      console.log('✓ Registered on portal');
    } catch (error) {
      if (error.message && error.message.includes('already has an account')) {
        console.log('✓ Portal already registered (using existing account)');
      } else {
        throw error;
      }
    }

    // Initialize filesystem
    await s5.fs.ensureIdentityInitialized();

    s5Instance = s5;
    console.log('✓ S5 instance initialized');
  }

  return s5Instance;
}

/**
 * HTTP Request Handler
 */
async function handleRequest(req, res) {
  // CORS headers
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.setHeader('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization');

  if (req.method === 'OPTIONS') {
    res.writeHead(200);
    res.end();
    return;
  }

  const url = new URL(req.url, `http://${req.headers.host}`);
  console.log(`${req.method} ${url.pathname}`);

  try {
    // Health check endpoint
    if (url.pathname === '/health' || url.pathname === '/s5/health') {
      res.writeHead(200, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({ status: 'ok', version: '0.9.0-beta' }));
      return;
    }

    // Extract path from URL: /s5/fs/{path} → {path}
    const match = url.pathname.match(/^\/s5\/fs\/(.+)$/);
    if (!match) {
      res.writeHead(404, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({ error: 'Not found' }));
      return;
    }

    let fsPath = match[1];

    // S5.js requires paths to start with home/ or archive/
    // Prepend home/ if not already prefixed
    if (!fsPath.startsWith('home/') && !fsPath.startsWith('archive/')) {
      fsPath = `home/${fsPath}`;
    }

    const s5 = await initializeS5();

    // PUT: Store data
    if (req.method === 'PUT') {
      // Read binary body
      const chunks = [];
      for await (const chunk of req) {
        chunks.push(chunk);
      }
      const data = Buffer.concat(chunks);

      // Store data at path
      await s5.fs.put(fsPath, data);

      console.log(`✓ PUT ${fsPath} (${data.length} bytes)`);

      res.writeHead(200, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({ success: true, size: data.length }));
      return;
    }

    // GET: Retrieve data
    if (req.method === 'GET') {
      // Retrieve data
      let data = await s5.fs.get(fsPath);

      if (data === null || data === undefined) {
        console.log(`✗ GET ${fsPath} - Not found`);
        res.writeHead(404, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ error: 'Not found' }));
        return;
      }

      // Handle JSON objects (S5.js auto-parses .json files)
      // Convert back to Buffer for HTTP transmission
      if (typeof data === 'object' && !(data instanceof Buffer) && !(data instanceof Uint8Array)) {
        data = Buffer.from(JSON.stringify(data));
      }

      const byteLength = Buffer.byteLength(data);
      console.log(`✓ GET ${fsPath} (${byteLength} bytes)`);

      res.writeHead(200, { 'Content-Type': 'application/octet-stream' });
      res.end(data);
      return;
    }

    // HEAD: Check if file exists
    if (req.method === 'HEAD') {
      // Check if data exists
      let data = await s5.fs.get(fsPath);

      if (data === null || data === undefined) {
        console.log(`✗ HEAD ${fsPath} - Not found`);
        res.writeHead(404);
        res.end();
        return;
      }

      // Handle JSON objects (S5.js auto-parses .json files)
      if (typeof data === 'object' && !(data instanceof Buffer) && !(data instanceof Uint8Array)) {
        data = Buffer.from(JSON.stringify(data));
      }

      // Get byte length (works for Buffer, Uint8Array, etc.)
      const byteLength = Buffer.byteLength(data);
      console.log(`✓ HEAD ${fsPath} (${byteLength} bytes)`);
      res.writeHead(200, {
        'Content-Type': 'application/octet-stream',
        'Content-Length': byteLength
      });
      res.end();
      return;
    }

    // DELETE: Remove data
    if (req.method === 'DELETE') {
      // Delete data
      await s5.fs.delete(fsPath);

      console.log(`✓ DELETE ${fsPath}`);

      res.writeHead(200, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({ success: true }));
      return;
    }

    // Unsupported method
    res.writeHead(405, { 'Content-Type': 'application/json' });
    res.end(JSON.stringify({ error: 'Method not allowed' }));

  } catch (error) {
    console.error('Error handling request:', error);
    res.writeHead(500, { 'Content-Type': 'application/json' });
    res.end(JSON.stringify({
      error: error.message,
      stack: process.env.NODE_ENV === 'development' ? error.stack : undefined
    }));
  }
}

/**
 * Start server
 */
const server = http.createServer(handleRequest);

server.listen(PORT, HOST, () => {
  console.log('╔════════════════════════════════════════════════════════════╗');
  console.log('║    Enhanced S5.js Test Server (v0.9.0-beta)               ║');
  console.log('╚════════════════════════════════════════════════════════════╝');
  console.log();
  console.log(`✓ Server listening on: http://${HOST}:${PORT}`);
  console.log(`✓ Health check: http://localhost:${PORT}/health`);
  console.log();
  console.log('Ready for vector database integration tests!');
  console.log('Press Ctrl+C to stop.');
  console.log();
});

// Graceful shutdown
process.on('SIGTERM', () => {
  console.log('\nReceived SIGTERM, shutting down gracefully...');
  server.close(() => {
    console.log('Server closed');
    process.exit(0);
  });
});

process.on('SIGINT', () => {
  console.log('\nReceived SIGINT, shutting down gracefully...');
  server.close(() => {
    console.log('Server closed');
    process.exit(0);
  });
});
